# Copyright 2020 Jim O'Regan
# Apache 2.0

import 'alphabet.grm' as a;
import 'utils.grm' as u;

delzero = "0".utf8 : "".utf8;
insspace = u.insspace;

card_1_9_m_nom = Optimize[StringFile['card-1-9-m-nom.tsv', 'utf8', 'utf8']];
card_1_9_m_gen = Optimize[StringFile['card-1-9-m-gen.tsv', 'utf8', 'utf8']];
card_1_9_m_ins = Optimize[StringFile['card-1-9-m-ins.tsv', 'utf8', 'utf8']];

card_11_19_m_nom = Optimize[StringFile['card-11-19-nom.tsv', 'utf8', 'utf8']];
card_11_19_m_gen = Optimize[StringFile['card-11-19-gen.tsv', 'utf8', 'utf8']];
card_11_19_m_ins = Optimize[StringFile['card-11-19-ins.tsv', 'utf8', 'utf8']];

card_10_90_m_nom = Optimize[StringFile['card-10-90-nom.tsv', 'utf8', 'utf8']];
card_10_90_m_gen = Optimize[StringFile['card-10-90-gen.tsv', 'utf8', 'utf8']];
card_10_90_m_ins = Optimize[StringFile['card-10-90-ins.tsv', 'utf8', 'utf8']];

card_100_900_m_nom = Optimize[StringFile['card-100-900-nom.tsv', 'utf8', 'utf8']];
card_100_900_m_gen = Optimize[StringFile['card-100-900-gen.tsv', 'utf8', 'utf8']];
card_100_900_m_ins = Optimize[StringFile['card-100-900-ins.tsv', 'utf8', 'utf8']];

nozero = CDRewrite[
	("0".utf8 : "".utf8)+,
	"",
	"[EOS]".utf8,
	a.sigma_star];
nums_20_90 = Project[card_10_90_m_nom, 'input'] - "10".utf8;

card_20_90_m_nom = nums_20_90 @ card_10_90_m_nom;
card_20_90_m_nom_nozero = Optimize[Invert[Invert[card_20_90_m_nom] @ nozero]];
card_20_90_m_gen = nums_20_90 @ card_10_90_m_gen;
card_20_90_m_gen_nozero = Optimize[Invert[Invert[card_20_90_m_gen] @ nozero]];
card_20_90_m_ins = nums_20_90 @ card_10_90_m_ins;
card_20_90_m_ins_nozero = Optimize[Invert[Invert[card_20_90_m_ins] @ nozero]];

export base_card_1_99_m_nom = (
	card_11_19_m_nom |
	card_10_90_m_nom |
	card_20_90_m_nom_nozero insspace card_1_9_m_nom);
export base_card_1_99_m_gen = (
	card_11_19_m_gen |
	card_10_90_m_gen |
	card_20_90_m_gen_nozero insspace card_1_9_m_gen);
export base_card_1_99_m_ins = (
	card_11_19_m_ins |
	card_10_90_m_ins |
	card_20_90_m_ins_nozero insspace card_1_9_m_ins);
# This version for appending to higher (hundreds, etc.)
# so the 0 before single digits is not optional
inc_card_1_99_m_nom = Optimize[(delzero card_1_9_m_nom | base_card_1_99_m_nom)];
inc_card_1_99_m_gen = Optimize[(delzero card_1_9_m_gen | base_card_1_99_m_gen)];
inc_card_1_99_m_ins = Optimize[(delzero card_1_9_m_ins | base_card_1_99_m_ins)];
# Non-appending version (1, 01 | 101 etc)
noinc_card_1_99_m_nom = Optimize[(delzero? card_1_9_m_nom | base_card_1_99_m_nom)];
noinc_card_1_99_m_gen = Optimize[(delzero? card_1_9_m_gen | base_card_1_99_m_gen)];
noinc_card_1_99_m_ins = Optimize[(delzero? card_1_9_m_ins | base_card_1_99_m_ins)];

# for use with ordinals
export card_100_900_m_nom_nozero = Optimize[Invert[Invert[card_100_900_m_nom] @ nozero]];
card_100_900_m_gen_nozero = Optimize[Invert[Invert[card_100_900_m_gen] @ nozero]];
card_100_900_m_ins_nozero = Optimize[Invert[Invert[card_100_900_m_ins] @ nozero]];

base_card_1_999_m_nom = (
	card_100_900_m_nom |
	card_100_900_m_nom_nozero insspace inc_card_1_99_m_nom);
base_card_1_999_m_gen = (
	card_100_900_m_gen |
	card_100_900_m_gen_nozero insspace inc_card_1_99_m_gen);
base_card_1_999_m_ins = (
	card_100_900_m_ins |
	card_100_900_m_ins_nozero insspace inc_card_1_99_m_ins);
export inc_card_1_999_m_nom = Optimize[(delzero inc_card_1_99_m_nom | base_card_1_999_m_nom)];
inc_card_1_999_m_gen = Optimize[(delzero inc_card_1_99_m_gen | base_card_1_999_m_gen)];
inc_card_1_999_m_ins = Optimize[(delzero inc_card_1_99_m_ins | base_card_1_999_m_ins)];
noinc_card_1_999_m_nom = Optimize[(delzero? noinc_card_1_99_m_nom | base_card_1_999_m_nom)];
noinc_card_1_999_m_gen = Optimize[(delzero? noinc_card_1_99_m_gen | base_card_1_999_m_gen)];
noinc_card_1_999_m_ins = Optimize[(delzero? noinc_card_1_99_m_ins | base_card_1_999_m_ins)];

one_digit = ("0"? "0")? "1";
plural_digits_tens = ("0" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9");
inc_plural_digits =  a.Digits plural_digits_tens ("2" | "3" | "4");
inc_nom_thousands_pl = Optimize[inc_plural_digits @ inc_card_1_999_m_nom];
digit_1_9 = a.Digits - "0";
digit_2_9 = digit_1_9 - "1";
units_qnt = ("5" | "6" | "7" | "8" | "9");
gt10_units_qnt = units_qnt | "1";
inc_quantity_digits = ("0" "0" units_qnt |
	digit_1_9 "0" "0" |
	digit_1_9 "0" gt10_units_qnt |
	a.Digits a.dTeens |
	a.Digits digit_2_9 "0" |
	a.Digits digit_2_9 gt10_units_qnt);
noinc_quantity_digits = (("0"? "0")? units_qnt |
	digit_1_9 "0" "0" |
	digit_1_9 "0" gt10_units_qnt |
	digit_1_9 a.dTeens |
	digit_1_9 digit_2_9 "0" |
	digit_1_9 digit_2_9 gt10_units_qnt |
	"0"? a.dTeens |
	"0"? digit_2_9 "0" |
	"0"? digit_2_9 gt10_units_qnt);

inc_digits_2_99 = Project[inc_card_1_99_m_gen, 'input'] - one_digit;
inc_digits_2_999 = Project[inc_nom_thousands_pl, 'input'] - one_digit;
export inc_nom_thousands_qnt = inc_quantity_digits @  inc_card_1_999_m_nom;
either_1000_nom_nozeros = (
	("1".utf8 : "jeden tysiąc".utf8) |
	("1".utf8 : "tysiąc".utf8));
either_1000_nom = either_1000_nom_nozeros ("000".utf8 : "".utf8);
inc_either_1000_nom = delzero delzero either_1000_nom;
noinc_either_1000_nom = (delzero? delzero)? either_1000_nom;
thousand_zeros_pl = "000".utf8 : " tysiące".utf8;
thousand_zeros_qnt = "000".utf8 : " tysięcy".utf8;
thousand_nozeros_pl = "".utf8 : " tysiące".utf8;
thousand_nozeros_qnt = "".utf8 : " tysięcy".utf8;
export inc_card_1_999_000_m_nom = (
	(inc_either_1000_nom) |
	(inc_nom_thousands_pl thousand_zeros_pl) |
	(inc_nom_thousands_qnt thousand_zeros_qnt));
inc_card_1_999_000_m_nom_nozero = inc_card_1_999_000_m_nom @ nozero;
func del_thousand[n] {
	return u.replace_input_suffix[("000" : ""), n];
}
export inc_card_1_999_999_m_nom = Optimize[(
	(del_thousand[inc_card_1_999_000_m_nom] insspace inc_card_1_999_m_nom) |
	("000" : "") inc_card_1_999_m_nom |
	inc_card_1_999_000_m_nom)];
#export card_1_999_999_m_nom = (
#	(del_thousand[inc_card_1_999_000_m_nom] insspace inc_card_1_999_m_nom) |
#	(("0"? "0")? "0")? noinc_card_1_999_m_nom |
#	noinc_card_1_999_000_m_nom);
# card_100_900_m_nom_nozero

# one: an acceptor with the singular form of the word (milion, tysiąc)
# different from both:
# pl: transducer mapping digits to words for plurals (xx2, xx3, xx4)
# (e.g.: inc_nom_thousands_pl)
# qnt: transducer mapping digits to words for 'quantities' (xx5 - xx9)
# (e.g.: inc_nom_thousands_qnt)
func gen_next[one, pl, qnt, prev, leading_zeros] {
	# inc_either_1000
	either_one = (("1" : "jeden ") u.I[one] | ("1" : " ") u.I[one]);
	plrw = CDRewrite[
		("ąc".utf8 : "ące".utf8) | ("ion".utf8 : "iony".utf8) | ("ard".utf8 : "ardy".utf8),
		"",
		"[EOS]",
		a.sigma_star];	
	qntrw = CDRewrite[
		("ąc".utf8 : "ęcy".utf8) | ("ion".utf8 : "ionów".utf8) | ("ard".utf8 : "ardów".utf8),
		"",
		"[EOS]",
		a.sigma_star];	
	pl_word = Project[one @ plrw, 'output'];
	qnt_word = Project[one @ qntrw, 'output'];
	zeros_pl = u.D["000"] u.I[" "] u.I[pl_word];
	zeros_qnt = u.D["000"] u.I[" "] u.I[qnt_word];
	cur_card_1_999 = (
		(either_one) |
		(pl zeros_pl) |
		(qnt zeros_qnt));
	return Optimize[((del_thousand[cur_card_1_999] u.insspace prev) |
		(leading_zeros prev) |
		cur_card_1_999)];
}

test = gen_next["tysiąc", inc_nom_thousands_pl, inc_nom_thousands_qnt, inc_card_1_999_m_nom, u.D["000"]];
dummy = AssertEqual[inc_card_1_999_999_m_nom, test];
